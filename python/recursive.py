# 递归函数：以一个函数在内部调用本身
# def fact(n):
#   if n==1:
#     return 1
#   return n*fact(n-1)
# print(fact(1000))

# 递归函数的优点是 定义简单，逻辑清晰，所有的递归函数都可以写成循环的方式，但是循环的逻辑不如递归清晰
# 使用递归函数需要注意防止栈溢出。在计算机中函数调用是通过栈stack这种数据结构实现的，
# 每当进入一个函数调用，栈就会增加一层栈帧，返回栈就会减少一层栈帧。
# 由于栈的大小不是无限的，所以递归调用的次数过多，会导致栈溢出。



# 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环效果是一样的，所以把循环看成是一种特殊的尾递归函数也是可以的。

# 尾递归是指，在函数返回的时候调用自身本身，并且return语句不能包含表达式。
# 这样编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。



def fact(n):
  return fact_iter(n, 1)

def fact_iter(num, product):
  if num == 1:
    return product
  return fact_iter(num-1, num*product)

# print(fact(5))

# 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出
# 遗憾的是，大多数编程语言没有对尾递归做优化，python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出

# 使用递归函数的有点是逻辑简单清晰，缺点是过深的调用会导致栈溢出
# 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环等价，没有循环语句的编程语言只能通过尾递归实现循环
# python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出问题


# 汉诺塔的移动可以调用递归函数非常简单的实现
def move(n, a, b, c):
  if n == 1:
    print(a,'->',c)
  else:
    move(n-1, a, c, b)
    move(1, a, b, c)
    move(n-1, b, a, c)
a='A'
b='B'
c='C'
  
print(move(3, a, b, c))